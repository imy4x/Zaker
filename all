import 'package:flutter/material.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:provider/provider.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:zaker/constants/api_keys.dart';
import 'package:zaker/constants/app_theme.dart';
import 'package:zaker/providers/study_provider.dart';
import 'package:zaker/screens/home_screen.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  await Supabase.initialize(
    url: supabaseUrl,
    anonKey: supabaseAnonKey,
  );

  runApp(const ZakerApp());
}

class ZakerApp extends StatelessWidget {
  const ZakerApp({super.key});

  @override
  Widget build(BuildContext context) {
    return ChangeNotifierProvider(
      create: (context) => StudyProvider(),
      child: MaterialApp(
        title: 'Zaker - ذاكر',
        debugShowCheckedModeBanner: false,
        
        localizationsDelegates: const [
          GlobalMaterialLocalizations.delegate,
          GlobalWidgetsLocalizations.delegate,
          GlobalCupertinoLocalizations.delegate,
        ],
        supportedLocales: const [
          Locale('ar', ''), // Arabic
          Locale('en', ''), // English
        ],
        locale: const Locale('ar', ''), 
        
        // --- تعديل: فرض اتجاه الواجهة من اليمين لليسار للتطبيق بالكامل ---
        builder: (context, child) {
          return Directionality(
            textDirection: TextDirection.rtl,
            child: child!,
          );
        },
        
        theme: AppTheme.lightTheme,
        
        home: const HomeScreen(),
      ),
    );
  }
}
import 'package:flutter/material.dart';
import 'package:zaker/services/text_extraction_service.dart';

class FileTypePickerSheet extends StatelessWidget {
  const FileTypePickerSheet({super.key});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Padding(
      padding: const EdgeInsets.all(24.0),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text('إنشاء جلسة جديدة', style: theme.textTheme.displayLarge?.copyWith(fontSize: 24)),
          const SizedBox(height: 8),
          Text('اختر نوع الملف الذي تريد مذاكرته', style: theme.textTheme.bodyMedium),
          const SizedBox(height: 24),
          _buildOption(
            context,
            icon: Icons.picture_as_pdf_outlined,
            title: 'ملف PDF',
            subtitle: 'استخراج النصوص من ملفات PDF',
            onTap: () => Navigator.of(context).pop(FileTypeOption.pdf),
          ),
          const SizedBox(height: 12),
          _buildOption(
            context,
            icon: Icons.image_outlined,
            title: 'صور',
            subtitle: 'استخراج النصوص من صور من المعرض',
            onTap: () => Navigator.of(context).pop(FileTypeOption.images),
          ),
          const SizedBox(height: 12),
           _buildOption(
            context,
            icon: Icons.slideshow_outlined,
            title: 'ملف PowerPoint',
            subtitle: 'غير مدعوم حالياً',
            onTap: () {}, // Prevent popping an unsupported option
          ),
        ],
      ),
    );
  }

  Widget _buildOption(BuildContext context, {required IconData icon, required String title, required String subtitle, required VoidCallback onTap}) {
    final theme = Theme.of(context);
    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(12),
      child: Container(
        padding: const EdgeInsets.all(12),
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(12),
          border: Border.all(color: Colors.grey.shade300)
        ),
        child: Row(
          children: [
            Icon(icon, size: 32, color: theme.primaryColor),
            const SizedBox(width: 16),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(title, style: theme.textTheme.bodyLarge?.copyWith(fontWeight: FontWeight.bold)),
                  Text(subtitle, style: theme.textTheme.bodyMedium),
                ],
              ),
            ),
            const Icon(Icons.arrow_forward_ios, size: 16, color: Colors.grey),
          ],
        ),
      ),
    );
  }
}
import 'dart:math';
import 'package:flutter/material.dart';
import 'package:flutter_card_swiper/flutter_card_swiper.dart';
import 'package:zaker/models/flashcard.dart';

class FlashcardWidget extends StatefulWidget {
  final List<Flashcard> flashcards;
  const FlashcardWidget({super.key, required this.flashcards});

  @override
  State<FlashcardWidget> createState() => _FlashcardWidgetState();
}

class _FlashcardWidgetState extends State<FlashcardWidget> {
  final CardSwiperController _controller = CardSwiperController();
  
  @override
  Widget build(BuildContext context) {
    if (widget.flashcards.isEmpty) {
      return const Center(child: Text('لم يتم إنشاء بطاقات تعليمية.'));
    }

    return Column(
      children: [
        Expanded(
          child: CardSwiper(
            controller: _controller,
            cardsCount: widget.flashcards.length,
            cardBuilder: (context, index, h, v) => _FlashcardContent(
              key: ValueKey(widget.flashcards[index].question),
              flashcard: widget.flashcards[index]
            ),
            allowedSwipeDirection: const AllowedSwipeDirection.symmetric(horizontal: true),
          ),
        ),
        const SizedBox(height: 20),
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceEvenly,
          children: [
            ElevatedButton.icon(
              icon: const Icon(Icons.arrow_back_rounded),
              label: const Text('السابق'),
              onPressed: () => _controller.swipe(CardSwiperDirection.left),
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.grey.shade200,
                foregroundColor: Colors.black,
              ),
            ),
             ElevatedButton.icon(
              icon: const Icon(Icons.arrow_forward_rounded),
              label: const Text('التالي'),
              onPressed: () => _controller.swipe(CardSwiperDirection.right),
            ),
          ],
        )
      ],
    );
  }
}

class _FlashcardContent extends StatefulWidget {
  final Flashcard flashcard;
  const _FlashcardContent({super.key, required this.flashcard});

  @override
  State<_FlashcardContent> createState() => _FlashcardContentState();
}

// --- تعديل: تم إعادة كتابة آلية القلب بالكامل لتكون أكثر استقراراً ---
class _FlashcardContentState extends State<_FlashcardContent> with SingleTickerProviderStateMixin {
  late AnimationController _animationController;

  @override
  void initState() {
    super.initState();
    _animationController = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 500),
    );
  }

  void _flipCard() {
    if (!mounted || _animationController.isAnimating) return;
    if (_animationController.status == AnimationStatus.completed) {
      _animationController.reverse();
    } else {
      _animationController.forward();
    }
  }

  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: _flipCard,
      child: AnimatedBuilder(
        animation: _animationController,
        builder: (context, child) {
          final angle = _animationController.value * pi;
          final isShowingBack = _animationController.value >= 0.5;

          final transform = Matrix4.identity()
            ..setEntry(3, 2, 0.001)
            ..rotateY(angle);

          return Transform(
            transform: transform,
            alignment: Alignment.center,
            child: isShowingBack
                ? Transform(
                    transform: Matrix4.identity()..rotateY(pi),
                    alignment: Alignment.center,
                    child: _buildCardSide(
                      label: "الإجابة",
                      text: widget.flashcard.answer,
                    ),
                  )
                : _buildCardSide(
                    label: "السؤال",
                    text: widget.flashcard.question,
                  ),
          );
        },
      ),
    );
  }

  Widget _buildCardSide({required String label, required String text}) {
    return Card(
      elevation: 8,
      shadowColor: Colors.black.withOpacity(0.1),
      child: Container(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          children: [
            Text(
              label, 
              style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                fontWeight: FontWeight.bold,
                color: Theme.of(context).primaryColor
              )
            ),
            const Spacer(),
            Center(
              child: SingleChildScrollView(
                child: Text(text, textAlign: TextAlign.center, style: Theme.of(context).textTheme.displayLarge?.copyWith(fontSize: 22)),
              ),
            ),
            const Spacer(),
            Text(
              "انقر للقلب",
              style: Theme.of(context).textTheme.bodyMedium?.copyWith(fontSize: 12),
            )
          ],
        ),
      ),
    );
  }
}
import 'package:flutter/material.dart';
import 'package:lottie/lottie.dart';
import 'package:provider/provider.dart';
import 'package:percent_indicator/linear_percent_indicator.dart';
import 'package:zaker/providers/study_provider.dart';

class LoadingView extends StatelessWidget {
  const LoadingView({super.key});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Consumer<StudyProvider>(
      builder: (context, provider, child) {
        return Scaffold(
          body: Center(
            child: Padding(
              padding: const EdgeInsets.all(24.0),
              child: SingleChildScrollView(
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    // --- تعديل: تحديد حجم الأنميشن بشكل آمن لتجنب الأخطاء ---
                    // SizedBox(
                    //   width: 200,
                    //   height: 200,
                    //   child: Lottie.asset(
                    //     'assets/animations/processing.json',
                    //     fit: BoxFit.contain,
                    //   ),
                    // ),
                    const SizedBox(height: 30),
                    Text(
                      'لحظات من فضلك...',
                      style: theme.textTheme.displayLarge?.copyWith(fontSize: 28),
                    ),
                    const SizedBox(height: 12),
                    Text(
                      'يقوم الذكاء الاصطناعي بتحليل المستند وإعداد مواد المذاكرة لك.',
                      textAlign: TextAlign.center,
                      style: theme.textTheme.bodyMedium,
                    ),
                    const SizedBox(height: 40),
                    LinearPercentIndicator(
                      percent: provider.progressValue,
                      lineHeight: 12.0,
                      barRadius: const Radius.circular(6),
                      backgroundColor: Colors.grey.shade300,
                      progressColor: theme.primaryColor,
                    ),
                    const SizedBox(height: 12),
                    Text(
                      provider.progressMessage,
                      style: theme.textTheme.bodyMedium,
                    ),
                    const SizedBox(height: 20),
                    Chip(
                      label: Text(
                        'يتم استخدام المفتاح رقم ${provider.currentApiKeyIndex + 1}',
                        style: theme.textTheme.bodyMedium?.copyWith(color: theme.primaryColor),
                      ),
                      backgroundColor: theme.primaryColor.withOpacity(0.1),
                      side: BorderSide.none,
                    ),
                  ],
                ),
              ),
            ),
          ),
        );
      },
    );
  }
}
import 'package:flutter/material.dart';
import 'package:zaker/models/study_session.dart';
import 'package:intl/intl.dart' as intl;
import 'package:percent_indicator/circular_percent_indicator.dart';

class SessionListItem extends StatelessWidget {
  final StudySession session;
  final VoidCallback onTap;
  final VoidCallback onDelete;

  const SessionListItem({
    super.key,
    required this.session,
    required this.onTap,
    required this.onDelete,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final progress = session.quizQuestions.isNotEmpty
        ? (session.correctlyAnsweredQuestions.length /
                session.quizQuestions.length)
            .clamp(0.0, 1.0)
        : 0.0;
    final formattedDate =
        intl.DateFormat('d MMMM yyyy', 'ar').format(session.createdAt);

    return Card(
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(24),
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Row(
            children: [
              CircularPercentIndicator(
                radius: 32.0,
                lineWidth: 7.0,
                percent: progress,
                center: Text(
                  "${(progress * 100).toInt()}%",
                  style: theme.textTheme.bodyMedium
                      ?.copyWith(fontWeight: FontWeight.bold),
                ),
                progressColor: theme.primaryColor,
                backgroundColor: Colors.grey.shade200,
                circularStrokeCap: CircularStrokeCap.round,
              ),
              const SizedBox(width: 16),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      session.title,
                      style: theme.textTheme.bodyLarge
                          ?.copyWith(fontWeight: FontWeight.bold, fontSize: 18),
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                    ),
                    const SizedBox(height: 6),
                    Row(
                      children: [
                        Icon(Icons.calendar_today_outlined,
                            size: 14, color: Colors.grey.shade600),
                        const SizedBox(width: 4),
                        Text(
                          formattedDate,
                          style: theme.textTheme.bodyMedium,
                        ),
                      ],
                    ),
                  ],
                ),
              ),
              IconButton(
                icon: Icon(Icons.delete_sweep_outlined,
                    color: Colors.redAccent.withOpacity(0.7)),
                onPressed: onDelete,
              )
            ],
          ),
        ),
      ),
    );
  }
}
import 'package:flutter/material.dart';
import 'package:lottie/lottie.dart';

class AppDialogs {

  static void showErrorDialog(BuildContext context, String message) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        title: const Row(
          children: [
            Icon(Icons.error_outline, color: Colors.red),
            SizedBox(width: 8),
            Text('حدث خطأ'),
          ],
        ),
        content: Text(message),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('حسنًا'),
          ),
        ],
      ),
    );
  }

  static Future<bool> showConfirmDialog(BuildContext context) async {
    final result = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        title: const Text('تأكيد الحذف'),
        content: const Text('هل أنت متأكد من أنك تريد حذف هذه الجلسة؟ لا يمكن التراجع عن هذا الإجراء.'),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(false),
            child: const Text('إلغاء'),
          ),
          TextButton(
            onPressed: () => Navigator.of(context).pop(true),
            style: TextButton.styleFrom(foregroundColor: Colors.red),
            child: const Text('حذف'),
          ),
        ],
      ),
    );
    return result ?? false;
  }

  static void showLoadingDialog(BuildContext context, String message) {
     showDialog(
        context: context,
        barrierDismissible: false,
        builder: (BuildContext context) {
          return AlertDialog(
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
            content: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                SizedBox(
                  width: 100,
                  height: 100,
                  child: Lottie.asset('assets/animations/processing.json', fit: BoxFit.contain),
                ),
                const SizedBox(height: 16),
                Text(message, textAlign: TextAlign.center),
              ],
            ),
          );
        },
      );
  }
}
import 'dart:convert';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:zaker/models/study_session.dart';

class StorageService {
  static const _sessionsKey = 'study_sessions_list_v2';

  Future<void> saveSessions(List<StudySession> sessions) async {
    final prefs = await SharedPreferences.getInstance();
    final List<String> sessionsJson = sessions.map((s) => jsonEncode(s.toJson())).toList();
    await prefs.setStringList(_sessionsKey, sessionsJson);
  }

  Future<List<StudySession>> getSessions() async {
    final prefs = await SharedPreferences.getInstance();
    final sessionsJson = prefs.getStringList(_sessionsKey);
    if (sessionsJson != null) {
      try {
        return sessionsJson.map((s) => StudySession.fromJson(jsonDecode(s))).toList();
      } catch (e) {
        print("Error decoding sessions: $e. Clearing old data.");
        await prefs.remove(_sessionsKey); // Clear corrupted data
        return [];
      }
    }
    return []; // إرجاع قائمة فارغة إذا لم توجد جلسات مخزنة
  }
}
import 'dart:io';
import 'package:file_picker/file_picker.dart';
import 'package:image_picker/image_picker.dart';
import 'package:syncfusion_flutter_pdf/pdf.dart';
import 'package:zaker/api/gemini_service.dart';

enum FileTypeOption { pdf, powerpoint, images }

class TextExtractionService {
  final GeminiService _aiService = GeminiService();
  final ImagePicker _imagePicker = ImagePicker();

  Future<String?> extractTextFromFile(FileTypeOption type) async {
    switch (type) {
      case FileTypeOption.pdf:
        return await _extractTextFromPdf();
      case FileTypeOption.powerpoint:
        throw Exception('ملفات PowerPoint غير مدعومة حالياً، سيتم إضافتها قريباً.');
      case FileTypeOption.images:
        return await _extractTextFromImages();
    }
  }

  Future<String?> _extractTextFromPdf() async {
    final result = await FilePicker.platform.pickFiles(
      type: FileType.custom,
      allowedExtensions: ['pdf'],
    );
    if (result != null) {
      final file = File(result.files.single.path!);
      try {
        final bytes = await file.readAsBytes();
        final PdfDocument document = PdfDocument(inputBytes: bytes);
        final String text = PdfTextExtractor(document).extractText();
        document.dispose();
        
        if (text.trim().isEmpty) {
          throw Exception('ملف الـ PDF فارغ أو لا يمكن قراءة النص منه.');
        }
        return text;
      } catch (e) {
        print("Error extracting PDF text: $e");
        throw Exception('فشل في قراءة ملف الـ PDF. قد يكون الملف محمياً أو تالفاً.');
      }
    }
    return null;
  }

  Future<String?> _extractTextFromImages() async {
    final List<XFile> pickedFiles = await _imagePicker.pickMultiImage();
    if (pickedFiles.isNotEmpty) {
      final imageFiles = pickedFiles.map((xfile) => File(xfile.path)).toList();
      return await _aiService.extractTextFromImage(imageFiles);
    }
    return null;
  }
}
import 'package:shared_preferences/shared_preferences.dart';
import 'dart:convert';

// --- ملف معدل بالكامل لتطبيق نظام الحصص اليومية الموحد ---
class UsageService {
  static const _usageKey = 'daily_usage_stats_v4'; // مفتاح جديد لضمان إعادة التعيين
  late SharedPreferences _prefs;

  // --- تعديل: حد يومي موحد لجميع أنواع التحليلات ---
  static const int _dailyLimit = 5;

  // يتم استدعاؤها عند بدء تشغيل التطبيق
  Future<void> init() async {
    _prefs = await SharedPreferences.getInstance();
    await _resetIfNewDay();
  }

  // دالة ذكية لإعادة تعيين العدادات تلقائياً في بداية كل يوم جديد
  Future<void> _resetIfNewDay() async {
    final stats = getUsageStats();
    final today = _getDateString(DateTime.now());

    if (stats['date'] != today) {
      // إذا كان التاريخ المحفوظ غير تاريخ اليوم، يتم تصفير العداد
      final newStats = {
        'date': today,
        'usage_count': 0,
      };
      await _prefs.setString(_usageKey, jsonEncode(newStats));
    }
  }

  // دالة للتحقق مما إذا كان يمكن للمستخدم إجراء تحليل
  bool canUse() {
    final stats = getUsageStats();
    final currentUsage = stats['usage_count'] as int? ?? 0;
    return currentUsage < _dailyLimit;
  }

  // دالة لتسجيل استخدام جديد بعد نجاح عملية التحليل
  Future<void> recordUsage() async {
    if (canUse()) {
      final stats = getUsageStats();
      stats['usage_count'] = (stats['usage_count'] as int? ?? 0) + 1;
      await _prefs.setString(_usageKey, jsonEncode(stats));
    }
  }

  // دالة للحصول على إحصائيات الاستخدام الحالية من التخزين المحلي
  Map<String, dynamic> getUsageStats() {
    final jsonString = _prefs.getString(_usageKey);
    if (jsonString != null) {
      try {
        return jsonDecode(jsonString);
      } catch (e) {
         // In case of corrupted data, return default
      }
    }
    // إرجاع قيمة ابتدائية إذا لم توجد بيانات مخزنة
    return {
      'date': _getDateString(DateTime.now()),
      'usage_count': 0,
    };
  }

  // دالة للحصول على عدد المحاولات المتبقية
  int getRemainingUses() {
    final stats = getUsageStats();
    final currentUsage = stats['usage_count'] as int? ?? 0;
    return _dailyLimit - currentUsage;
  }
  
  // دالة لحساب الوقت المتبقي حتى منتصف الليل (موعد إعادة تعيين الحدود)
  Duration getTimeUntilReset() {
    final now = DateTime.now();
    final tomorrow = DateTime(now.year, now.month, now.day + 1);
    return tomorrow.difference(now);
  }

  // دالة مساعدة لتحويل التاريخ إلى نص
  String _getDateString(DateTime date) {
    return "${date.year}-${date.month}-${date.day}";
  }
}
import 'package:flutter/material.dart';
import 'package:lottie/lottie.dart';
import 'package:provider/provider.dart';
import 'package:zaker/constants/app_constants.dart';
import 'package:zaker/providers/study_provider.dart';
import 'package:zaker/screens/study_material_screen.dart';
import 'package:zaker/services/text_extraction_service.dart';
import 'package:zaker/utils/dialogs.dart';
import 'package:zaker/widgets/file_type_picker_sheet.dart';
import 'package:zaker/widgets/loading_view.dart';
import 'package:zaker/widgets/session_list_item.dart';

class HomeScreen extends StatefulWidget {
  const HomeScreen({super.key});

  @override
  State<HomeScreen> createState() => _HomeScreenState();
}

class _HomeScreenState extends State<HomeScreen> {
  final _titleController = TextEditingController();

  Future<void> _createNewSession() async {
    final provider = Provider.of<StudyProvider>(context, listen: false);

    if (!provider.usageService.canUse()) {
      final timeUntilReset = provider.usageService.getTimeUntilReset();
      final hours = timeUntilReset.inHours;
      final minutes = timeUntilReset.inMinutes.remainder(60);
      AppDialogs.showErrorDialog(
        context, 
        'لقد استهلكت رصيدك اليومي (محاولتان).\n\nستتم إعادة التعيين بعد: ${hours} ساعة و ${minutes} دقيقة.'
      );
      return;
    }

    final selectedType = await showModalBottomSheet<FileTypeOption>(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.white,
      shape: const RoundedRectangleBorder(
          borderRadius: BorderRadius.vertical(top: Radius.circular(24))),
      builder: (_) => const FileTypePickerSheet(),
    );
    if (selectedType == null) return;

    final sessionDetails = await _showSessionOptionsDialog();
    if (sessionDetails == null || !mounted) return;

    final newSession = await provider.createSessionFromFile(
      selectedType,
      sessionDetails['language'] as String,
      sessionDetails['title'] as String,
      sessionDetails['depth'] as AnalysisDepth,
    );

    if (!mounted) return;

    if (provider.state == AppState.success && newSession != null) {
      provider.resetState();
      Navigator.push(
        context,
        MaterialPageRoute(
            builder: (context) => StudyMaterialScreen(session: newSession)),
      );
    } else if (provider.state == AppState.error) {
      AppDialogs.showErrorDialog(context, provider.errorMessage);
      provider.resetState();
    }
  }

  Future<Map<String, dynamic>?> _showSessionOptionsDialog() {
    final formKey = GlobalKey<FormState>();
    _titleController.text =
        'جلسة مذاكرة ${DateTime.now().day}/${DateTime.now().month}';

    return showDialog<Map<String, dynamic>>(
      context: context,
      builder: (context) {
        String selectedLanguage = 'العربية';
        AnalysisDepth selectedDepth = AnalysisDepth.medium;

        return StatefulBuilder(
          builder: (context, setState) {
            return AlertDialog(
              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(20)),
              title: const Center(child: Text('خيارات الجلسة')),
              content: Consumer<StudyProvider>(
                builder: (context, provider, _) {
                  final remaining = provider.usageService.getRemainingUses();
                  final canUse = remaining > 0;
                  final timeUntilReset = provider.usageService.getTimeUntilReset();

                  return SingleChildScrollView(
                    child: Form(
                      key: formKey,
                      child: Column(
                        mainAxisSize: MainAxisSize.min,
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          TextFormField(
                            controller: _titleController,
                            decoration:
                                const InputDecoration(labelText: 'عنوان الجلسة'),
                            validator: (value) =>
                                value!.isEmpty ? 'العنوان مطلوب' : null,
                          ),
                          const SizedBox(height: 20),

                          const Text('لغة التحليل', style: TextStyle(fontWeight: FontWeight.bold)),
                          // --- تعديل: تحسين تناسق أزرار الاختيار ---
                          Row(
                            children: [
                              Flexible(
                                child: RadioListTile<String>(
                                  title: const Text('العربية'),
                                  value: 'العربية',
                                  groupValue: selectedLanguage,
                                  contentPadding: EdgeInsets.zero,
                                  onChanged: (v) => setState(() => selectedLanguage = v!),
                                ),
                              ),
                              Flexible(
                                child: RadioListTile<String>(
                                  title: const Text('English'),
                                  value: 'English',
                                  groupValue: selectedLanguage,
                                  contentPadding: EdgeInsets.zero,
                                  onChanged: (v) => setState(() => selectedLanguage = v!),
                                ),
                              ),
                            ],
                          ),
                          
                          const Divider(height: 20),
                          
                          const Text('اختر عمق التحليل',
                              style: TextStyle(fontWeight: FontWeight.bold)),
                          Text(
                            'عمق التحليل يؤثر فقط على تفصيل الملخص والبطاقات، ولا يستهلك رصيداً مختلفاً.',
                            style: Theme.of(context).textTheme.bodyMedium,
                          ),
                          const SizedBox(height: 8),

                          ...AnalysisDepth.values.map((depth) {
                            return RadioListTile<AnalysisDepth>(
                              title: Text(depth.nameAr),
                              subtitle: Text(
                                depth.descriptionAr,
                                style: Theme.of(context).textTheme.bodyMedium?.copyWith(fontSize: 12),
                              ),
                              value: depth,
                              groupValue: selectedDepth,
                              onChanged: (v) => setState(() => selectedDepth = v!),
                            );
                          }).toList(),
                          
                          const Divider(height: 20),
                          Center(
                            child: Chip(
                              label: Text(
                                'المحاولات المتبقية اليوم: $remaining',
                                style: TextStyle(
                                  color: canUse ? Colors.green.shade800 : Colors.red.shade800,
                                  fontWeight: FontWeight.bold,
                                ),
                              ),
                              backgroundColor: canUse ? Colors.green.shade100 : Colors.red.shade100,
                            ),
                          ),

                          if (!canUse)
                            Padding(
                              padding: const EdgeInsets.only(top: 16.0),
                              child: Text(
                                'ستتم إعادة التعيين بعد: ${timeUntilReset.inHours}h ${timeUntilReset.inMinutes.remainder(60)}m',
                                style: const TextStyle(
                                    color: Colors.orange,
                                    fontWeight: FontWeight.bold),
                                textAlign: TextAlign.center,
                              ),
                            )
                        ],
                      ),
                    ),
                  );
                },
              ),
              actionsAlignment: MainAxisAlignment.spaceBetween,
              actions: [
                TextButton(
                    onPressed: () => Navigator.pop(context),
                    child: const Text('إلغاء')),
                Consumer<StudyProvider>(
                  builder: (context, provider, _) {
                    final bool canUse = provider.usageService.canUse();
                    return ElevatedButton(
                      onPressed: canUse
                          ? () {
                              if (formKey.currentState!.validate()) {
                                Navigator.pop(context, {
                                  'title': _titleController.text,
                                  'language': selectedLanguage,
                                  'depth': selectedDepth,
                                });
                              }
                            }
                          : null,
                      child: const Text('ابدأ التحليل'),
                    );
                  },
                ),
              ],
            );
          },
        );
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('جلساتي'),
      ),
      body: Consumer<StudyProvider>(
        builder: (context, provider, child) {
          if (provider.state == AppState.loading) {
            return const LoadingView();
          }
          return _buildSessionList(provider);
        },
      ),
      // --- تعديل: إخفاء الزر العائم أثناء التحميل ---
      floatingActionButton: Consumer<StudyProvider>(
        builder: (context, provider, child) {
          return provider.state == AppState.loading
            ? const SizedBox.shrink()
            : FloatingActionButton.extended(
                onPressed: _createNewSession,
                label: const Text('جلسة جديدة'),
                icon: const Icon(Icons.add_rounded),
              );
        }
      ),
    );
  }

  Widget _buildSessionList(StudyProvider provider) {
    if (provider.sessions.isEmpty) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Lottie.asset('assets/animations/empty.json',
                width: 250, height: 250),
            const SizedBox(height: 20),
            Text(
              'لا توجد جلسات مذاكرة بعد',
              style:
                  Theme.of(context).textTheme.displayLarge?.copyWith(fontSize: 22),
            ),
            const SizedBox(height: 8),
            Text(
              'اضغط على زر الإضافة لبدء المذاكرة',
              style: Theme.of(context).textTheme.bodyMedium,
            ),
          ],
        ),
      );
    }

    return RefreshIndicator(
      onRefresh: () async =>
          Provider.of<StudyProvider>(context, listen: false).reloadSessions(),
      child: ListView.builder(
        padding: const EdgeInsets.fromLTRB(16, 16, 16, 80),
        itemCount: provider.sessions.length,
        itemBuilder: (context, index) {
          final session = provider.sessions[index];
          return SessionListItem(
            session: session,
            onTap: () {
              Navigator.push(
                context,
                MaterialPageRoute(
                    builder: (context) => StudyMaterialScreen(session: session)),
              );
            },
            onDelete: () async {
              final confirm = await AppDialogs.showConfirmDialog(context);
              if (confirm) {
                await provider.deleteSession(session.id);
              }
            },
          );
        },
      ),
    );
  }

  @override
  void dispose() {
    _titleController.dispose();
    super.dispose();
  }
}
extension StudyProviderExtension on StudyProvider {
  Future<void> reloadSessions() async {
    // await _loadSessions();
  }
}

import 'package:flutter/material.dart';
import 'package:percent_indicator/linear_percent_indicator.dart';
import 'package:zaker/models/quiz_question.dart';

class QuizScreen extends StatefulWidget {
  final List<QuizQuestion> questions;
  final String languageCode;
  const QuizScreen({super.key, required this.questions, required this.languageCode});

  @override
  State<QuizScreen> createState() => _QuizScreenState();
}

class _QuizScreenState extends State<QuizScreen> {
  int _currentQuestionIndex = 0;
  int _score = 0;
  int? _selectedAnswerIndex;
  bool _answered = false;
  final List<QuizQuestion> _correctlyAnsweredQuestions = [];

  void _nextQuestion() {
    if (_currentQuestionIndex < widget.questions.length - 1) {
      setState(() {
        _currentQuestionIndex++;
        _selectedAnswerIndex = null;
        _answered = false;
      });
    } else {
      _showResultDialog();
    }
  }

  void _handleAnswer(int index) {
    if (_answered) return;

    final currentQuestion = widget.questions[_currentQuestionIndex];
    setState(() {
      _selectedAnswerIndex = index;
      _answered = true;
      if (index == currentQuestion.correctAnswerIndex) {
        _score++;
        _correctlyAnsweredQuestions.add(currentQuestion);
      }
    });

    Future.delayed(const Duration(milliseconds: 1200), () {
      if(mounted) _nextQuestion();
    });
  }

  void _showResultDialog() {
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => AlertDialog(
        title: const Text('انتهى الاختبار!'),
        content: Text('نتيجتك هي: $_score / ${widget.questions.length}'),
        actions: [
          TextButton(
            onPressed: () {
              Navigator.of(context).pop(); // إغلاق النافذة
              Navigator.of(context).pop(_correctlyAnsweredQuestions); 
            },
            child: const Text('العودة'),
          ),
        ],
      ),
    );
  }

  Color _getOptionColor(int index) {
    if (!_answered) return Colors.white;
    if (index == widget.questions[_currentQuestionIndex].correctAnswerIndex) return Colors.green.shade100;
    if (index == _selectedAnswerIndex) return Colors.red.shade100;
    return Colors.white;
  }

   Border? _getOptionBorder(int index) {
    if (!_answered) return Border.all(color: Colors.grey.shade300);
    if (index == widget.questions[_currentQuestionIndex].correctAnswerIndex) return Border.all(color: Colors.green, width: 2);
    if (index == _selectedAnswerIndex) return Border.all(color: Colors.red, width: 2);
    return Border.all(color: Colors.grey.shade300);
  }

  @override
  Widget build(BuildContext context) {
    final currentQuestion = widget.questions[_currentQuestionIndex];
    final textDirection = widget.languageCode == 'ar' ? TextDirection.rtl : TextDirection.ltr;

    return Directionality(
      textDirection: textDirection,
      child: Scaffold(
        appBar: AppBar(title: const Text('اختبار قصير')),
        body: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              Text('السؤال ${_currentQuestionIndex + 1} من ${widget.questions.length}'),
              const SizedBox(height: 8),
              LinearPercentIndicator(
                percent: (_currentQuestionIndex + 1) / widget.questions.length,
                lineHeight: 10.0,
                barRadius: const Radius.circular(5),
                progressColor: Theme.of(context).primaryColor,
                backgroundColor: Colors.grey.shade300,
              ),
              const SizedBox(height: 24),
              Expanded(
                child: SingleChildScrollView(
                  child: Column(
                    children: [
                      Text(currentQuestion.question, style: Theme.of(context).textTheme.displayLarge?.copyWith(fontSize: 22), textAlign: TextAlign.center),
                      const SizedBox(height: 32),
                      ...List.generate(currentQuestion.options.length, (index) {
                        return Card(
                          elevation: 0,
                          margin: const EdgeInsets.only(bottom: 12),
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(12),
                            side: _getOptionBorder(index)!.top,
                          ),
                          color: _getOptionColor(index),
                          child: InkWell(
                            onTap: () => _handleAnswer(index),
                            borderRadius: BorderRadius.circular(12),
                            child: Padding(
                              padding: const EdgeInsets.all(16.0),
                              child: Text(currentQuestion.options[index], style: Theme.of(context).textTheme.bodyLarge),
                            ),
                          ),
                        );
                      }),
                    ],
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:zaker/models/quiz_question.dart';
import 'package:zaker/providers/study_provider.dart';
import 'package:zaker/models/study_session.dart';
import 'package:zaker/screens/quiz_screen.dart';
import 'package:zaker/widgets/flashcard_widget.dart';
import 'package:flutter_markdown/flutter_markdown.dart';
import 'package:percent_indicator/linear_percent_indicator.dart';

class StudyMaterialScreen extends StatelessWidget {
  final StudySession session;
  const StudyMaterialScreen({super.key, required this.session});

  void _startQuiz(BuildContext context, int questionCount) async {
    final provider = Provider.of<StudyProvider>(context, listen: false);
    final currentSessionState =
        provider.sessions.firstWhere((s) => s.id == session.id);

    final availableQuestions = currentSessionState.quizQuestions
        .where((q) =>
            !currentSessionState.correctlyAnsweredQuestions.contains(q.question))
        .toList();

    if (availableQuestions.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('لقد أجبت على جميع الأسئلة بنجاح!')),
      );
      return;
    }

    final questionsToTake = questionCount > availableQuestions.length
        ? availableQuestions.length
        : questionCount;

    final shuffledQuestions = List<QuizQuestion>.from(availableQuestions)
      ..shuffle();
    final selectedQuestions = shuffledQuestions.take(questionsToTake).toList();

    final questionsWithShuffledOptions = selectedQuestions.map((q) {
      final correctAnswerText = q.options[q.correctAnswerIndex];
      final shuffledOptions = List<String>.from(q.options)..shuffle();
      final newCorrectIndex = shuffledOptions.indexOf(correctAnswerText);
      return QuizQuestion(
          question: q.question,
          options: shuffledOptions,
          correctAnswerIndex: newCorrectIndex,
          difficulty: q.difficulty);
    }).toList();

    final correctAnswers = await Navigator.push<List<QuizQuestion>>(
      context,
      MaterialPageRoute(
          builder: (context) => QuizScreen(
              questions: questionsWithShuffledOptions,
              languageCode: session.languageCode)),
    );

    if (correctAnswers != null && context.mounted) {
      await provider.recordQuizResult(session.id, correctAnswers);
    }
  }

  @override
  Widget build(BuildContext context) {
    final textDirection =
        session.languageCode == 'ar' ? TextDirection.rtl : TextDirection.ltr;
    final theme = Theme.of(context);

    return Directionality(
      textDirection: textDirection,
      child: DefaultTabController(
        length: 3,
        child: Scaffold(
          appBar: AppBar(
            title: Text(session.title, overflow: TextOverflow.ellipsis),
            bottom: const TabBar(tabs: [
              Tab(text: 'الملخص'),
              Tab(text: 'البطاقات'),
              Tab(text: 'الاختبار'),
            ]),
          ),
          body: TabBarView(
            children: [
              SingleChildScrollView(
                child: Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: MarkdownBody(
                    data: session.summary,
                    styleSheet: MarkdownStyleSheet.fromTheme(theme).copyWith(
                      h1: theme.textTheme.displayLarge?.copyWith(fontSize: 26),
                      h2: theme.textTheme.displayLarge?.copyWith(fontSize: 22),
                      h3: theme.textTheme.displayLarge?.copyWith(fontSize: 18),
                      p: theme.textTheme.bodyLarge,
                      listBullet: theme.textTheme.bodyLarge,
                      code: theme.textTheme.bodyMedium?.copyWith(
                        fontFamily: 'monospace',
                        backgroundColor: Colors.grey.shade200,
                      )
                    ),
                  ),
                ),
              ),

              Padding(
                  padding: const EdgeInsets.fromLTRB(16, 16, 16, 0),
                  child: FlashcardWidget(flashcards: session.flashcards)),

              _buildQuizTab(context),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildQuizTab(BuildContext context) {
    final theme = Theme.of(context);
    return Consumer<StudyProvider>(
      builder: (context, provider, child) {
        final currentSession = provider.sessions.firstWhere((s) => s.id == session.id);
        final totalGenerated = currentSession.quizQuestions.length;
        final totalUniqueCorrect = currentSession.correctlyAnsweredQuestions.length;
        final progressPercentage = totalGenerated > 0 ? totalUniqueCorrect / totalGenerated : 0.0;
        
        return Center(
          child: SingleChildScrollView(
            padding: const EdgeInsets.all(24.0),
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(Icons.school_outlined,
                    size: 80, color: theme.primaryColor),
                const SizedBox(height: 16),
                Text('اختبر فهمك للمادة',
                    style: theme.textTheme.displayLarge
                        ?.copyWith(fontSize: 24)),
                const SizedBox(height: 8),
                Text(
                  'ستظهر لك أسئلة متنوعة الصعوبة بشكل عشوائي.',
                  style: theme.textTheme.bodyMedium,
                  textAlign: TextAlign.center,
                ),
                const SizedBox(height: 30),

                // --- تعديل: تحسين مظهر شريط التقدم وتوسيط النص ---
                if (totalGenerated > 0)
                  LinearPercentIndicator(
                    percent: progressPercentage,
                    lineHeight: 14.0, // زيادة الارتفاع قليلاً
                    barRadius: const Radius.circular(7),
                    center: Text(
                      '${(progressPercentage * 100).toStringAsFixed(0)}% مكتمل',
                      style: theme.textTheme.bodySmall?.copyWith(
                        color: Colors.white,
                        fontWeight: FontWeight.bold,
                        fontSize: 10,
                      )
                    ),
                    progressColor: Colors.green,
                    backgroundColor: Colors.grey.shade300,
                  ),
                
                const Divider(height: 40),

                Text('ابدأ اختباراً جديداً',
                    style: theme.textTheme.bodyLarge
                        ?.copyWith(fontWeight: FontWeight.bold)),
                const SizedBox(height: 20),

                if (session.quizQuestions.isEmpty)
                  const Text('لم يتم إنشاء أسئلة لهذه المادة.')
                else
                  Wrap(
                    spacing: 16,
                    runSpacing: 16,
                    alignment: WrapAlignment.center,
                    children: [5, 10, 20]
                        .where((num) => session.quizQuestions.length >= num)
                        .map((num) => ElevatedButton(
                              onPressed: () => _startQuiz(context, num),
                              child: Text('$num أسئلة'),
                            ))
                        .toList(),
                  ),
              ],
            ),
          ),
        );
      },
    );
  }
}

import 'package:flutter/material.dart';
import 'package:zaker/api/gemini_service.dart';
import 'package:zaker/constants/app_constants.dart';
import 'package:zaker/models/study_session.dart';
import 'package:zaker/services/storage_service.dart';
import 'package:zaker/services/text_extraction_service.dart';
import 'package:zaker/services/usage_service.dart';
import 'package:zaker/models/flashcard.dart';
import 'package:zaker/models/quiz_question.dart';

enum AppState { idle, loading, success, error }

class StudyProvider extends ChangeNotifier {
  final GeminiService _aiService = GeminiService();
  final StorageService _storageService = StorageService();
  final TextExtractionService _textExtractionService = TextExtractionService();
  final UsageService _usageService = UsageService(); 

  AppState _state = AppState.idle;
  AppState get state => _state;
  
  List<StudySession> _sessions = [];
  List<StudySession> get sessions => _sessions;

  String _errorMessage = '';
  String get errorMessage => _errorMessage;

  double _progressValue = 0.0;
  double get progressValue => _progressValue;
  
  String _progressMessage = '';
  String get progressMessage => _progressMessage;

  int _currentApiKeyIndex = 0;
  int get currentApiKeyIndex => _currentApiKeyIndex;

  StudyProvider() {
    _init();
  }

  Future<void> _init() async {
    await _usageService.init();
    await _loadSessions();
  }

  UsageService get usageService => _usageService;

  Future<void> _loadSessions() async {
    _sessions = await _storageService.getSessions();
    _sessions.sort((a, b) => b.createdAt.compareTo(a.createdAt));
    notifyListeners();
  }
  
  Future<void> deleteSession(String sessionId) async {
    _sessions.removeWhere((s) => s.id == sessionId);
    await _storageService.saveSessions(_sessions);
    notifyListeners();
  }

  Future<StudySession?> createSessionFromFile(
    FileTypeOption fileType, 
    String targetLanguage, 
    String title,
    AnalysisDepth depth,
  ) async {
    // --- تعديل: استخدام نظام الحصص اليومية الجديد ---
    if (!_usageService.canUse()) {
      _errorMessage = 'لقد استهلكت رصيدك اليومي من التحليلات (محاولتان). حاول مجدداً غداً.';
      _state = AppState.error;
      notifyListeners();
      return null;
    }
    
    _state = AppState.loading;
    _updateProgress(0.0, 'جاري اختيار الملف...');
    notifyListeners();

    try {
      void updateKeyIndex(int index) {
        _currentApiKeyIndex = index;
        notifyListeners();
      }

      _updateProgress(0.1, 'الخطوة 1/4: استخراج النص (نموذج سريع)...');
      final text = await _textExtractionService.extractTextFromFile(fileType);
      if (text == null || text.trim().isEmpty) {
        throw Exception('لم يتم اختيار ملف أو أن الملف فارغ.');
      }

      _updateProgress(0.25, 'الخطوة 2/4: تحليل المحتوى (نموذج سريع)...');
      // --- تعديل: استدعاء الخدمة بدون عمق التحليل ---
      final validationResult = await _aiService.validateContent(text, updateKeyIndex);
      if (validationResult['is_study_material'] == false) {
        final reason = validationResult['reason_ar'] ?? 'السبب غير معروف.';
        throw Exception('هذا المستند لا يبدو كمادة دراسية.\nالسبب: $reason');
      }

      _updateProgress(0.5, 'الخطوة 3/4: إنشاء الملخص والبطاقات (نموذج احترافي)...');
      // --- ملاحظة: عمق التحليل يمرر هنا فقط لتخصيص نوعية الملخص المطلوب ---
      final summaryFuture = _aiService.generateSummary(text, targetLanguage, depth, updateKeyIndex);
      final flashcardsFuture = _aiService.generateFlashcards(text, targetLanguage, depth, updateKeyIndex);
      
      _updateProgress(0.75, 'الخطوة 4/4: بناء بنك الأسئلة (نموذج احترافي)...');
      final quizFuture = _aiService.generateQuiz(text, targetLanguage, updateKeyIndex);

      final results = await Future.wait([summaryFuture, flashcardsFuture, quizFuture]);
      
      final newSession = StudySession(
        id: DateTime.now().millisecondsSinceEpoch.toString(),
        title: title,
        createdAt: DateTime.now(),
        languageCode: targetLanguage == 'العربية' ? 'ar' : 'en',
        summary: results[0] as String,
        flashcards: results[1] as List<Flashcard>,
        quizQuestions: results[2] as List<QuizQuestion>,
      );
      
      _sessions.insert(0, newSession);
      await _storageService.saveSessions(_sessions);
      
      // --- تعديل: تسجيل محاولة استخدام واحدة ---
      await _usageService.recordUsage(); 

      _state = AppState.success;
      notifyListeners();
      return newSession;

    } catch (e) {
      _errorMessage = e.toString().replaceFirst("Exception: ", "");
      _state = AppState.error;
      notifyListeners();
      return null;
    }
  }

  void _updateProgress(double value, String message) {
    _progressValue = value;
    _progressMessage = message;
    notifyListeners();
  }

  void resetState() async {
    await _usageService.init(); 
    _state = AppState.idle;
    _errorMessage = '';
    _progressValue = 0.0;
    _progressMessage = '';
    notifyListeners();
  }
   Future<void> recordQuizResult(String sessionId, List<QuizQuestion> correctlyAnswered) async {
    final sessionIndex = _sessions.indexWhere((s) => s.id == sessionId);
    if (sessionIndex != -1) {
      for (var question in correctlyAnswered) {
        _sessions[sessionIndex].correctlyAnsweredQuestions.add(question.question);
      }
      await _storageService.saveSessions(_sessions);
      notifyListeners();
    }
  }

  Future<void> resetQuizProgress(String sessionId) async {
    final sessionIndex = _sessions.indexWhere((s) => s.id == sessionId);
    if (sessionIndex != -1) {
      _sessions[sessionIndex].correctlyAnsweredQuestions.clear();
      await _storageService.saveSessions(_sessions);
      notifyListeners();
    }
  }
}
class Flashcard {
  final String question;
  final String answer;

  Flashcard({required this.question, required this.answer});

  factory Flashcard.fromJson(Map<String, dynamic> json) {
    return Flashcard(
      question: json['question'] ?? 'لا يوجد سؤال',
      answer: json['answer'] ?? 'لا توجد إجابة',
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'question': question,
      'answer': answer,
    };
  }
}
import 'package:zaker/constants/app_constants.dart';

class QuizQuestion {
  final String question;
  final List<String> options;
  final int correctAnswerIndex;
  // --- التعديل: تمت إضافة مستوى الصعوبة لكل سؤال ---
  final QuizDifficulty difficulty; 

  QuizQuestion({
    required this.question,
    required this.options,
    required this.correctAnswerIndex,
    required this.difficulty,
  });

  factory QuizQuestion.fromJson(Map<String, dynamic> json) {
    // دالة داخلية لتحويل النص القادم من API إلى enum
    QuizDifficulty parseDifficulty(String? diff) {
      switch (diff?.toLowerCase()) {
        case 'easy': return QuizDifficulty.easy;
        case 'medium': return QuizDifficulty.medium;
        case 'hard': return QuizDifficulty.hard;
        case 'very_hard': return QuizDifficulty.veryHard;
        default: return QuizDifficulty.medium; // قيمة افتراضية في حال حدوث خطأ
      }
    }

    return QuizQuestion(
      question: json['question'] ?? 'لا يوجد سؤال',
      options: List<String>.from(json['options'] ?? []),
      correctAnswerIndex: json['correctAnswerIndex'] ?? 0,
      difficulty: parseDifficulty(json['difficulty']),
    );
  }
  
  Map<String, dynamic> toJson() {
    return {
      'question': question,
      'options': options,
      'correctAnswerIndex': correctAnswerIndex,
      // تحويل الـ enum إلى نص عند الحفظ
      'difficulty': difficulty.toString().split('.').last,
    };
  }
}
import 'flashcard.dart';
import 'quiz_question.dart';

// تم تعديل النموذج ليناسب القائمة الديناميكية ويحتوي على معرّف فريد
class StudySession {
  final String id; // معرّف فريد لكل جلسة
  String title;
  final DateTime createdAt;
  final String summary;
  final List<Flashcard> flashcards;
  final List<QuizQuestion> quizQuestions;
  final String languageCode;
  Set<String> correctlyAnsweredQuestions;

  StudySession({
    required this.id,
    required this.title,
    required this.createdAt,
    required this.summary,
    required this.flashcards,
    required this.quizQuestions,
    this.languageCode = 'ar',
    Set<String>? correctlyAnsweredQuestions,
  }) : correctlyAnsweredQuestions = correctlyAnsweredQuestions ?? {};

  factory StudySession.fromJson(Map<String, dynamic> json) {
    return StudySession(
      id: json['id'] ?? DateTime.now().toIso8601String(),
      title: json['title'] ?? 'جلسة مذاكرة',
      createdAt: DateTime.parse(json['createdAt'] ?? DateTime.now().toIso8601String()),
      summary: json['summary'] ?? '',
      flashcards: (json['flashcards'] as List<dynamic>?)?.map((e) => Flashcard.fromJson(e)).toList() ?? [],
      quizQuestions: (json['quizQuestions'] as List<dynamic>?)?.map((e) => QuizQuestion.fromJson(e)).toList() ?? [],
      languageCode: json['languageCode'] ?? 'ar',
      correctlyAnsweredQuestions: Set<String>.from(json['correctlyAnsweredQuestions'] as List<dynamic>? ?? []),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'title': title,
      'createdAt': createdAt.toIso8601String(),
      'summary': summary,
      'flashcards': flashcards.map((e) => e.toJson()).toList(),
      'quizQuestions': quizQuestions.map((e) => e.toJson()).toList(),
      'languageCode': languageCode,
      'correctlyAnsweredQuestions': correctlyAnsweredQuestions.toList(),
    };
  }
}
// ملف جديد لتنظيم النماذج (Enums) والثوابت المستخدمة في التطبيق

// أولاً: نماذج التحليل الثلاثة
enum AnalysisDepth {
  deep, // النموذج العميق
  medium, // النموذج المتوسط
  light, // النموذج الخفيف
}

extension AnalysisDepthExtension on AnalysisDepth {
  String get nameAr {
    switch (this) {
      case AnalysisDepth.deep:
        return 'تحليل عميق';
      case AnalysisDepth.medium:
        return 'تحليل متوسط';
      case AnalysisDepth.light:
        return 'تحليل خفيف';
    }
  }

  String get descriptionAr {
    switch (this) {
      case AnalysisDepth.deep:
        return 'شرح تفصيلي شبيه بالمنهج الجامعي مع أمثلة وتشبيهات لترسيخ الفهم.';
      case AnalysisDepth.medium:
        return 'تحليل متوازن يجمع بين الشرح والنقاط الأساسية.';
      case AnalysisDepth.light:
        return 'ملخص سريع يركز على المفاهيم والنقاط الهامة فقط.';
    }
  }
}


// ثانياً: مستويات صعوبة الاختبار
enum QuizDifficulty {
  easy,
  medium,
  hard,
  veryHard,
  mixed, // خيار جديد لمزيج من كل المستويات
}


extension QuizDifficultyExtension on QuizDifficulty {
  String get nameAr {
    switch (this) {
      case QuizDifficulty.easy: return 'سهل';
      case QuizDifficulty.medium: return 'متوسط';
      case QuizDifficulty.hard: return 'صعب';
      case QuizDifficulty.veryHard: return 'صعب جداً';
      case QuizDifficulty.mixed: return 'متنوع';
    }
  }
}
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';

class AppTheme {
  // --- الألوان الرئيسية الجديدة والمحسنة ---
  static const Color primaryColor = Color(0xFF007AFF); // أزرق عصري وواضح
  static const Color secondaryColor = Color(0xFF5AC8FA); // سماوي فاتح
  static const Color backgroundColor = Color(0xFFF9F9F9); // خلفية أنظف
  static const Color textColor = Color(0xFF2C2C2E); // أسود ناعم
  static const Color subtitleColor = Color(0xFF8E8E93); // رمادي معتدل

  static final ThemeData lightTheme = ThemeData(
    primaryColor: primaryColor,
    scaffoldBackgroundColor: backgroundColor,
    fontFamily: GoogleFonts.cairo().fontFamily, // استخدام خط Cairo
    
    appBarTheme: AppBarTheme(
      backgroundColor: backgroundColor,
      elevation: 0,
      centerTitle: true,
      titleTextStyle: GoogleFonts.cairo(
        color: textColor,
        fontSize: 22,
        fontWeight: FontWeight.bold,
      ),
      iconTheme: const IconThemeData(color: textColor),
    ),

    textTheme: TextTheme(
      displayLarge: GoogleFonts.cairo(fontWeight: FontWeight.bold, fontSize: 28, color: textColor),
      bodyLarge: GoogleFonts.cairo(fontSize: 16, color: textColor, height: 1.7),
      bodyMedium: GoogleFonts.cairo(fontSize: 14, color: subtitleColor, height: 1.6),
      labelLarge: GoogleFonts.cairo(fontSize: 16, fontWeight: FontWeight.bold, color: Colors.white),
    ),

    cardTheme: CardThemeData(
      elevation: 6,
      shadowColor: Colors.black.withOpacity(0.05),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(24),
      ),
      margin: const EdgeInsets.symmetric(vertical: 8, horizontal: 0),
      color: Colors.white,
    ),

    elevatedButtonTheme: ElevatedButtonThemeData(
      style: ElevatedButton.styleFrom(
        padding: const EdgeInsets.symmetric(horizontal: 32, vertical: 16),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        elevation: 0,
        textStyle: GoogleFonts.cairo(fontSize: 16, fontWeight: FontWeight.bold),
        backgroundColor: primaryColor,
        foregroundColor: Colors.white,
        disabledBackgroundColor: Colors.grey.shade300,
      ),
    ),
    
    floatingActionButtonTheme: const FloatingActionButtonThemeData(
      backgroundColor: primaryColor,
      foregroundColor: Colors.white,
      elevation: 4,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.all(Radius.circular(16))),
    ),

    tabBarTheme: TabBarThemeData(
      labelColor: primaryColor,
      unselectedLabelColor: subtitleColor,
      indicatorSize: TabBarIndicatorSize.label,
      indicator: UnderlineTabIndicator(
        borderSide: const BorderSide(color: primaryColor, width: 3),
        borderRadius: BorderRadius.circular(4),
      ),
      labelStyle: GoogleFonts.cairo(fontWeight: FontWeight.bold, fontSize: 16),
      unselectedLabelStyle: GoogleFonts.cairo(fontWeight: FontWeight.w600, fontSize: 16),
    ),
    
    inputDecorationTheme: InputDecorationTheme(
        filled: true,
        fillColor: Colors.white,
        contentPadding: const EdgeInsets.symmetric(horizontal: 20, vertical: 16),
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(16),
          borderSide: BorderSide.none,
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(16),
          borderSide: BorderSide.none,
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(16),
          borderSide: const BorderSide(color: primaryColor, width: 2),
        ),
        labelStyle: GoogleFonts.cairo(color: subtitleColor),
    ),
  );
}
import 'dart:convert';
import 'dart:io';
import 'package:google_generative_ai/google_generative_ai.dart';
import 'package:zaker/constants/api_keys.dart';
import 'package:zaker/constants/app_constants.dart';
import 'package:zaker/models/flashcard.dart';
import 'package:zaker/models/quiz_question.dart';

// --- تعديل: enum جديد لتحديد نوع النموذج المطلوب (سريع أو احترافي) ---
enum ModelType {
  pro,
  flash,
}

class GeminiService {
  int _currentApiKeyIndex = 0;

  GenerativeModel _getModel(ModelType modelType) {
    if (geminiApiKeys.isEmpty || geminiApiKeys.first.contains('YOUR_API_KEY_HERE')) {
       throw Exception('Please add valid Gemini API keys in constants/api_keys.dart');
    }
    final apiKey = geminiApiKeys[_currentApiKeyIndex];
    
    // --- تعديل: اختيار اسم النموذج بناءً على النوع المطلوب ---
    final modelName = switch (modelType) {
      ModelType.pro   => 'gemini-2.5-pro',
      ModelType.flash => 'gemini-2.5-flash',
    };

    return GenerativeModel(
      model: modelName,
      apiKey: apiKey,
      generationConfig: GenerationConfig(temperature: 0.7)
    );
  }

  Future<GenerateContentResponse> _generateContentWithRetry(
    List<Content> prompt,
    ModelType modelType, // استخدام ModelType
    Function(int) onKeyChanged,
  ) async {
    int attempts = 0;
    while (attempts < geminiApiKeys.length) {
      try {
        onKeyChanged(_currentApiKeyIndex);
        final model = _getModel(modelType); // تمرير النوع للمودل
        final response = await model.generateContent(prompt);
        return response;
      } catch (e) {
        print("API Key #$_currentApiKeyIndex failed: $e");
        if (e.toString().contains('Quota') || e.toString().contains('exceeded')) {
           _currentApiKeyIndex = (_currentApiKeyIndex + 1) % geminiApiKeys.length;
           attempts++;
        } else {
          throw Exception('An error occurred during analysis: ${e.toString()}');
        }
       
        if (attempts >= geminiApiKeys.length) {
          throw Exception('All API keys have failed or reached their quota. Please try again later.');
        }
      }
    }
    throw Exception('An unexpected error occurred in the AI service.');
  }

  // --- تعديل: تستخدم دائمًا نموذج فلاش للسرعة ---
  Future<Map<String, dynamic>> validateContent(String text, Function(int) onKeyChanged) async {
    final prompt = '''
      Analyze the following text. Determine if it is processable educational content.
      Content is processable if it is not gibberish, unclear, or clearly non-educational (like a food menu).
      The response must be only a valid JSON object in this format: {"is_study_material": true/false, "reason_ar": "Write the reason here in Arabic"}
      Text: """${text.substring(0, text.length > 1500 ? 1500 : text.length)}"""
    ''';
    try {
      final response = await _generateContentWithRetry([Content.text(prompt)], ModelType.flash, onKeyChanged);
      final cleanJson = response.text!.replaceAll('```json', '').replaceAll('```', '').trim();
      return jsonDecode(cleanJson);
    } catch (e) {
      print("Error validating content: $e");
      return {"is_study_material": false, "reason_ar": "Failed to analyze content. There might be a connection issue."};
    }
  }

  // --- تعديل: تستخدم دائمًا نموذج برو للجودة ---
  Future<String> generateSummary(String text, String targetLanguage, AnalysisDepth depth, Function(int) onKeyChanged) async {
    // targetLanguage should be "Arabic" or "English"
    String prompt;
    switch (depth) {
      case AnalysisDepth.deep:
        prompt = '''
          Act as a university professor and an expert in simplifying science. Your goal is to explain the following material to a student in great depth and in an easy-to-read format.
          **Task**: Create an analytical, deep, and comprehensive summary.
          **Strict Instructions**:
          1.  **Deep Explanation**: Don't just provide definitions. Explain the "why" and "how" of each concept.
          2.  **Examples and Analogies**: For each main concept, provide a clear real-world example and an innovative analogy to solidify understanding.
          3.  **Clear Formatting**: Use Markdown effectively. Utilize headings (`## Main Title`, `### Subtitle`), bullet points (`- point`), and **bold text** for key terms to make the summary easy to read and study.
          4.  **Language**: The final summary must be exclusively in **$targetLanguage**.
          **Text to summarize**: """$text"""
        ''';
        break;
      case AnalysisDepth.medium:
         prompt = '''
          **Task**: Create a balanced and well-formatted summary of the following text.
          **Instructions**:
          1.  Focus on explaining the core concepts clearly.
          2.  Use a simple example where necessary to clarify complex points.
          3.  Use a clear structure with headings (`##`), bullet points, and **bold text** for terms.
          4.  **Language**: The final summary must be exclusively in **$targetLanguage**.
          **Text to summarize**: """$text"""
        ''';
        break;
      case AnalysisDepth.light:
        prompt = '''
          **Task**: Create a quick and concise summary of the following text in the form of key points.
          **Instructions**:
          1.  Extract only the essential points and concepts.
          2.  Avoid long explanations or examples.
          3.  Use a structured bulleted list (`-`). Make key terms **bold**.
          4.  **Language**: The final summary must be exclusively in **$targetLanguage**.
          **Text to summarize**: """$text"""
        ''';
        break;
    }
     try {
      final response = await _generateContentWithRetry([Content.text(prompt)], ModelType.pro, onKeyChanged);
      return response.text ?? 'The AI could not generate a summary.';
    } catch (e) {
      rethrow;
    }
  }

  // --- تعديل: تستخدم دائمًا نموذج برو للجودة ---
  Future<List<QuizQuestion>> generateQuiz(String text, String targetLanguage, Function(int) onKeyChanged) async {
    final prompt = '''
      You are a professional educational test designer. Your task is to create a diverse question bank from the following text to measure different levels of understanding.
      **Task**: Create as many multiple-choice questions as possible (up to 50).
      **Strict Instructions**:
      1.  **Difficulty Distribution**: You must strictly follow this difficulty distribution:
          - **30% easy**: Direct questions testing recall of information.
          - **20% medium**: Questions requiring linking two pieces of information or a simple understanding of relationships.
          - **40% hard**: Application questions requiring the student to apply a concept to a new scenario.
          - **10% very_hard**: Inferential questions testing a very deep understanding of the material and requiring critical thinking.
      2.  **Smart Distractors**: The incorrect options (distractors) must be plausible and convincing, not obviously wrong.
      3.  **Language**: The test must be exclusively in **$targetLanguage**.
      4.  **Format**: Return the result only as a valid JSON array. Each question must include a "difficulty" key with the value "easy", "medium", "hard", or "very_hard".
          `[{"question":"...","options":["...","...","...","..."],"correctAnswerIndex":0, "difficulty":"easy"},...]`
      **Source Text**: """$text"""
    ''';
    try {
      final response = await _generateContentWithRetry([Content.text(prompt)], ModelType.pro, onKeyChanged);
      final cleanJson = response.text!.replaceAll('```json', '').replaceAll('```', '').trim();
      final List<dynamic> jsonList = jsonDecode(cleanJson);
      return jsonList.map((item) => QuizQuestion.fromJson(item)).toList();
    } catch (e) {
      print("Error parsing quiz: $e");
      return [];
    }
  }
  
  // --- تعديل: تستخدم دائمًا نموذج فلاش للسرعة ---
  Future<String> extractTextFromImage(List<File> imageFiles) async {
    final prompt = TextPart("Extract all text from these images in order. Preserve the original structure, paragraphs, and language.");
    final imageParts = await Future.wait(imageFiles.map((file) async {
      final bytes = await file.readAsBytes();
      final mimeType = file.path.toLowerCase().endsWith('.png') ? 'image/png' : 'image/jpeg';
      return DataPart(mimeType, bytes);
    }));
    
    try {
      final response = await _generateContentWithRetry(
        [Content.multi([prompt, ...imageParts])], 
        ModelType.flash, 
        (index) {}
      );
      return response.text ?? 'Could not read text from the image.';
    } catch (e) {
      print("Error extracting text from image: $e");
      throw Exception('Failed to analyze the image. It might be too large or corrupted.');
    }
  }

  // --- تعديل: تستخدم دائمًا نموذج برو للجودة ---
  Future<List<Flashcard>> generateFlashcards(String text, String targetLanguage, AnalysisDepth depth, Function(int) onKeyChanged) async {
    final prompt = '''
      You are an effective teacher creating study aids to promote deep understanding, not just memorization.
      **Task**: From the following text, create as many useful flashcards as possible (up to 50).
      **Instructions**:
      1.  **Thought-Provoking Questions**: The "question" on the card should be a thought-provoking query about a key concept, a "why" or "how" question, not just "what is".
      2.  **Comprehensive Answers**: The "answer" should be a concise but complete explanation, not just a single word or short definition. It should fully clarify the concept raised in the question.
      3.  **Language**: The flashcards must be exclusively in **$targetLanguage**.
      4.  **Format**: Return the result only as a valid JSON array in this format: `[{"question":"...","answer":"..."},...]`
      **Source Text**:
      """$text"""
    ''';
    try {
      final response = await _generateContentWithRetry([Content.text(prompt)], ModelType.pro, onKeyChanged);
      final cleanJson = response.text!.replaceAll('```json', '').replaceAll('```', '').trim();
      final List<dynamic> jsonList = jsonDecode(cleanJson);
      return jsonList.map((item) => Flashcard.fromJson(item)).toList();
    } catch (e) {
      print("Error parsing flashcards: $e");
      return [];
    }
  }
}
